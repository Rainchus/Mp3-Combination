import argparse
import os
import glob
import ninja_syntax

#requires python 3.9 minimum

rom_folder_path = "rom/"
mp3_path = f'{rom_folder_path}mp3-temp.z64'
mp2_path = f'{rom_folder_path}mp2.z64'
mp1_path = f'{rom_folder_path}mp1.z64'
mk64_path = f'{rom_folder_path}mk64.z64'

c_flags = "-O2 -Wall -Wno-missing-braces -mtune=vr4300 -march=vr4300 -mabi=32 -fomit-frame-pointer -mno-abicalls -fno-pic -G0 -fno-inline -DF3DEX_GBI_2"

#Files compiled and automatically DMAed to expansion pak ram on boot
c_files = glob.glob('src/**/*.c', recursive=True)

# .s files are put into expansion pak ram and are *not* intended to have their headersize changed
s_files = glob.glob('asm/**/*.s', recursive=True)

# .asm files are assembly files that often change the headersize
asm_files = glob.glob('asm/**/*.asm', recursive=True)

def append_binary_files(input1, input2):
    with open(input1, "ab") as f1, open(input2, "rb") as f2:
        f1.write(f2.read())

def GetGameListAndSetCFlags():
    global c_flags
    parser = argparse.ArgumentParser(description="Build combined string name.")
    parser.add_argument('-mp1', action='store_true', help="Add -mp1 to the name")
    parser.add_argument('-mk64', action='store_true', help="Add -mk64 to the name")

    args = parser.parse_args()

    parts = ["mp3-mp2"]
    extra_games = ["mp1", "mk64"]
    for key, value in vars(args).items():
        if key in (extra_games) and value:
            parts.append(key)

    combined_name = "-".join(parts)
    split_name = combined_name.split("-")

    #make sure a rom exist for each
    for i in split_name:
        rom_path_str = mp3_path if i == "mp3" else f"{rom_folder_path}{i}.z64"
        if not os.path.exists(f"{rom_folder_path}{i}.z64"):
            raise ValueError(f"File {rom_path_str} not found!")
        if i == "mp3":
            pass
        elif i == "mp2":
            pass
        elif i == "mp1":
            c_flags += " -DMP1"
        elif i == "mk64":
            c_flags += " -DMK64"
        else:
            raise ValueError(f"Unknown flag: {i}")

    #print(f"Combined: {combined_name}")
    return combined_name

def build_combined_rom_file(final_rom_name):
    split_name = final_rom_name.removesuffix(".z64").split("-")
    final_rom_path = f"{rom_folder_path}{final_rom_name}"
    for i in split_name:
        rom = mp3_path if i == "mp3" else f"{rom_folder_path}{i}.z64"
        append_binary_files(final_rom_path, rom)

def create_main_asm():
    header = f"""
//Automatically generated by configure.py, do not edit
.n64 // Let armips know we're coding for the N64 architecture
.open "rom/{combined_baserom_name}", "rom/{combined_rom_mod_name}", 0 // Open the ROM file
"""

    footer = """
.align 8
PAYLOAD_END_RAM:
.close //close file
"""
    # Create an ASM file that includes other .asm and .s files and imports .o files
    with open("asm/main.asm", 'w') as file:
        file.write(header)

        file.write(".include \"rom_start.asm\"\n")

        for asm_file in asm_files:
            if asm_file.endswith('main.asm'):
                continue
            file.write(f".include \"{asm_file}\"\n")

        file.write(".include \"headersize.asm\"\n")

        for s_file in s_files:
            file.write(f".include \"{s_file}\"\n")

        for c_file in c_files:
            obj_file = os.path.join('obj', os.path.relpath(c_file, 'src')).replace('.c', '.o')
            file.write(f".importobj \"{obj_file}\"\n")

        file.write(footer)

def create_ninja_file(combined_rom_mod_name, combined_baserom_name):
    global c_flags
    with open('build.ninja', 'w') as buildfile:
        ninja = ninja_syntax.Writer(buildfile)
        ninja.variable('CC', 'mips64-elf-gcc')
        ninja.variable('CFLAGS', c_flags)
        ninja.variable('INCLUDE_FLAGS', '-Iinclude -Isrc')

        ninja.rule(
            "cc",
            command="$CC $CFLAGS $INCLUDE_FLAGS -c $in -o $out",
            description="Compiling $in to $out",
            depfile="$out.d",
            deps="gcc",
        )


        # List to collect all object files
        obj_files = []

        # Create build statements for each .c file
        for c_file in c_files:
            obj_file = os.path.join('obj', os.path.relpath(c_file, 'src')).replace('.c', '.o')
            ninja.build(obj_file, 'cc', c_file)
            obj_files.append(obj_file)

        # Add a phony target that depends on all object files
        ninja.build('all', 'phony', obj_files)

        # Add a rule to run armips on main.asm after all .o files are built
        ninja.rule(
            "armips",
            command="armips asm/main.asm -sym syms.txt",
            description="Running armips on main.asm"
        )

        # Create a build statement to run armips after all .o files are built
        ninja.build('run_armips', 'armips', 'all')

        # Add a rule to run n64crc.exe on mod.z64 after armips completes
        ninja.rule(
            "n64crc",
            command=f"n64crc.exe rom/{combined_rom_mod_name}",
            description=f"Running n64crc.exe on {combined_rom_mod_name}"
        )

        # Create a build statement to run n64crc.exe after armips
        ninja.build('run_n64crc', 'n64crc', 'run_armips')

if __name__ == "__main__":
    combined_name = GetGameListAndSetCFlags()
    combined_baserom_name = combined_name + ".z64"
    combined_rom_mod_name = combined_name + ".mod.z64"

    if os.path.exists(f"{rom_folder_path}{combined_baserom_name}"):
        os.remove(f"{rom_folder_path}{combined_baserom_name}")

    build_combined_rom_file(combined_baserom_name)
    create_ninja_file(combined_rom_mod_name, combined_baserom_name)
    create_main_asm()