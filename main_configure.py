import argparse
import os
import glob
import ninja_syntax
import sys

# Requires python 3.9 minimum

rom_folder_path = "rom/"
mp3_path = f'{rom_folder_path}mp3-temp.z64'
mp2_path = f'{rom_folder_path}mp2.z64'
mp1_path = f'{rom_folder_path}mp1.z64'
mk64_path = f'{rom_folder_path}mk64.z64'

c_flags = "-O2 -Wall -Wno-missing-braces -mtune=vr4300 -march=vr4300 -mabi=32 -fomit-frame-pointer -mno-abicalls -fno-pic -G0 -fno-inline -DF3DEX_GBI_2"

#Files compiled and automatically DMAed to expansion pak ram on boot
c_files = glob.glob('src/**/*.c', recursive=True)

# .s files are put into expansion pak ram and are *not* intended to have their headersize changed
s_files = glob.glob('asm/**/*.s', recursive=True)

# .asm files are assembly files that often change the headersize
asm_files = glob.glob('asm/**/*.asm', recursive=True)

def append_binary_files(input1, input2):
    with open(input1, "ab") as f1, open(input2, "rb") as f2:
        f1.write(f2.read())

def parse_and_validate_args():
    global c_flags
    parser = argparse.ArgumentParser(description="Build combined string name.")
    parser.add_argument('-mp1', action='store_true', help="Add -mp1 to the name")
    parser.add_argument('-mk64', action='store_true', help="Add -mk64 to the name")

    args = parser.parse_args()

    parts = ["mp3-mp2"]
    extra_games = []

    if args.mk64:
        extra_games.append("mp1")
        extra_games.append("mk64")
    elif args.mp1:
        extra_games.append("mp1")

    parts.extend(extra_games)

    combined_name = "-".join(parts)
    split_name = combined_name.split("-")

    for i in split_name:
        rom_path_str = mp3_path if i == "mp3" else f"{rom_folder_path}{i}.z64"
        if not os.path.exists(f"{rom_folder_path}{i}.z64"):
            raise ValueError(f"File {rom_path_str} not found!")
        if i == "mp3":
            pass
        elif i == "mp2":
            pass
        elif i == "mp1":
            c_flags += " -DMP1"
        elif i == "mk64":
            c_flags += " -DMK64"
        else:
            raise ValueError(f"Unknown flag: {i}")

    return combined_name

def build_combined_rom_file(final_rom_name):
    split_name = final_rom_name.removesuffix(".z64").split("-")
    final_rom_path = f"{rom_folder_path}{final_rom_name}"
    if os.path.exists(final_rom_path):
        os.remove(final_rom_path)
    for i in split_name:
        rom = mp3_path if i == "mp3" else f"{rom_folder_path}{i}.z64"
        append_binary_files(final_rom_path, rom)

def create_main_asm():
    header = f"""
// Automatically generated by configure.py, do not edit
.n64
.open "rom/{combinedBaseromName}", "rom/{combinedRomModName}", 0
"""

    footer = """
.align 8
PAYLOAD_END_RAM:
.close
"""
    with open("asm/main.asm", 'w') as file:
        file.write(header)
        file.write(".include \"rom_start.asm\"\n")

        for asm_file in asm_files:
            if asm_file.endswith('main.asm'):
                continue
            file.write(f".include \"{asm_file}\"\n")

        file.write(".include \"headersize.asm\"\n")

        for s_file in s_files:
            file.write(f".include \"{s_file}\"\n")

        for c_file in c_files:
            obj_file = os.path.join('obj', os.path.relpath(c_file, 'src')).replace('.c', '.o')
            file.write(f".importobj \"{obj_file}\"\n")

        file.write(footer)

def create_ninja_file(combinedRomModName, combinedBaseromName):
    global c_flags
    with open('build.ninja', 'w') as buildfile:
        ninja = ninja_syntax.Writer(buildfile)
        ninja.variable('CC', 'mips64-elf-gcc')
        ninja.variable('CFLAGS', c_flags)
        ninja.variable('INCLUDE_FLAGS', '-Iinclude -Isrc')

        ninja.rule(
            "cc",
            command="$CC $CFLAGS $INCLUDE_FLAGS -c $in -o $out",
            description="Compiling $in to $out",
            depfile="$out.d",
            deps="gcc",
        )

        obj_files = []
        for c_file in c_files:
            obj_file = os.path.join('obj', os.path.relpath(c_file, 'src')).replace('.c', '.o')
            ninja.build(obj_file, 'cc', c_file)
            obj_files.append(obj_file)

        ninja.build('all', 'phony', obj_files)

        ninja.rule(
            "armips",
            command="armips asm/main.asm -sym syms.txt",
            description="Running armips on main.asm"
        )
        ninja.build('run_armips', 'armips', 'all')

        # Determine trimming requirements
        trim_size = None
        if combinedRomModName == "mp3-mp2.mod.z64":
            trim_size = 64 * 1024 * 1024
        elif combinedRomModName == "mp3-mp2-mp1.mod.z64":
            trim_size = 96 * 1024 * 1024

        # Add trimming rule if needed
        if trim_size is not None:
            ninja.rule(
                "trim",
                command=f"python -c \"f=open('rom/{combinedRomModName}', 'rb+'); f.truncate({trim_size})\"",
                description=f"Trimming ROM to {trim_size} bytes"
            )
            ninja.build('trim_rom', 'trim', 'run_armips')

        ninja.rule(
            "n64crc",
            command=f"n64crc.exe rom/{combinedRomModName}",
            description=f"Calculating CRC for {combinedRomModName}"
        )

        # Link build steps based on trimming
        if trim_size is not None:
            ninja.build('run_n64crc', 'n64crc', 'trim_rom')
        else:
            ninja.build('run_n64crc', 'n64crc', 'run_armips')

if __name__ == "__main__":
    combinedName = parse_and_validate_args()
    combinedBaseromName = f"{combinedName}.z64"
    combinedRomModName = f"{combinedName}.mod.z64"

    if os.path.exists(f"{rom_folder_path}{combinedBaseromName}"):
        os.remove(f"{rom_folder_path}{combinedBaseromName}")

    build_combined_rom_file(combinedBaseromName)
    create_ninja_file(combinedRomModName, combinedBaseromName)
    create_main_asm()